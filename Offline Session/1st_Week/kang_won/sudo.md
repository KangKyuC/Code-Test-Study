문제는 전위 순회 방식에서 -> 트리의 부모 자식 관계를 역으로 추산하는 문제

전위 순회를  -> 트리로 구성하고 -> 트리의 서로 다른 부모를 찾는 방식으로 설계함은 어떨까 함.
-------------------------------------
그런데 다른 생각이 발생
스택으로 구현할 수는 없을까?

0 push
1 push
2 push
1 > if) 이미 스택에 있는 값인가?
다시 값이 있는 값 조회 (1)
2 pop -> 2의 부모 1

3 push
4 push
3 > if) 스택 top-1과 같은 값?
4 pop -> 4의 부모 3
5 push
3 > if) 이미 스택에 있는 값인가??
5 pop -> 5의 부모 3
1 > if) 스택 top과 같은 값?
1 push
6 > if) 스택 top과 같은 값?
6 push
1 > if) 스택 top과 같은 값?
6 pop -> 6의 부모 1
0 > if) 스택 top과 같은 값?
0 push
7 > if) 스택 top과 같은 값?
7 push
8 > if) 스택 top과 같은 값?
8 push
7 > if) 스택 top과 같은 값?
8 pop -> 8의 부모 7
9 > if) 스택 top과 같은 값?
9 push
7 > if) 스택 top과 같은 값?
9 pop -> 9의 부모 7

0 > if) 스택 top과 같은 값?
0  push

추가 값 없음.

위에서부터 pop
0 7 0 1 3 1 0

다시 스택에 저장

0 push
7  > if) 스택 top-1과 같은 값?
7 push
0  > if) 스택 top-1과 같은 값?
7 pop -> 7의 부모 0

1  > if) 스택 top-1과 같은 값?
1 push
3 > if) 스택 top-1과 같은 값?
3 push
1 > if) 스택 top-1과 같은 값?
3 pop -> 3의 부모 1
0 > if) 스택 top-1과 같은 값?
-----------------------------------------------------------------------
- 순회 경로 A
- 스택 = []
- 부모 리스트 = [len(set(제공된 값))]
	=> 근데 이 방법은 set 객체 생성 필요
	=> 딕셔너리로 진행하는 편이 나으려나
	=> 근데 어차피 set 객체는 GC 됨.
- 순회 경로 A의 첫 요소는 루트 → 부모는 -1, push

- for a in A[1:]:
    - 만약 스택의 top과 a가 다르면:
        - A[i]는 스택의 top의 자식
        - 부모[a] = 스택[-1]
        - push A[i]
    - 만약 A[i]가 이미 스택에 있고, top이 A[i]라면:
        - 현재 탐색이 끝났다는 뜻 → pop

0 1 2 1 3 4 3 5 3 1 6 1 0 7 8 7 9 7 0
[-1, 0, 1, 1, 3, 3, 1, 0, 7, 7]

0 1 3 4 3 1 2 1 6 1 3 5 3 1 0
