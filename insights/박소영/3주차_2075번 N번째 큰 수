★★문제 요약★★

표에는 총 25개의 숫자가 있다.
→ (5행 × 5열 = 25개)

이 중에서,
5번째로 큰 수를 구하시오. (N=5니까)



★★문제 진짜 의도★★

전체 25개의 숫자 중에서
5번째로 큰 수를 찾아서 출력해! 

전부 저장해서 정렬하면 메모리가 뻑날 수도 있다...

★★전략: 큰 수 N개만 유지하면서 버리는 방식


★★이 문제에 필요한 개념★★

1. heapq — 파이썬의 우선순위 큐(힙) 라이브러리
이 문제는 모든 수 중에서 N번째로 큰 수를 구해야 하기 때문에,
수를 정렬하거나, 큐처럼 관리할 자료구조가 필요해.
그 역할을 해주는 게 바로 힙!

   ***heapq의 특징
   파이썬의 heapq는 기본이 '최소 힙(min-heap)'
   즉, 항상 가장 작은 값이 맨 위에 있어.
====================================
  import heapq

  heap = []
  heapq.heappush(heap, 10)  # 넣기(10)
  heapq.heappop(heap)       # 빼기(힙에서 가장 작은 값 꺼내기)
 ====================================


★★★슈도코드★★★

1.힙을 만든다
(기본이 작은 값이 먼저 나오는 '최소 힙')

2.숫자를 하나씩 힙에 넣는다.

3.만약 힙에 N개보다 많아지면?
  제일 작은 값을 제거해버린다!

★★이중 for문(=중첩 for문)의 동작 원리 간단 설명★★

==========================================================
matrix = [
    [1, 2, 3],
    [4, 5, 6]            # 개념설명에서 matrix에 딕셔너리 안쓰고 리스트를 한개 더 썼네?
]

for row in matrix:        # 먼저 한 줄(row)을 꺼내
    for item in row:      # 그 줄에서 다시 한 칸(item)씩 꺼내
        print(item)
==========================================================

출력은 세로로 나옴. print(item)가 항상 하나 출력후 다음 줄에서 출력하기 떄문에.
1
2
3
4
5
6

가로 출력 희망시 print(item, end=" ")을 써야함. 1 2 3 4 5 6 


★★아까 위에서 matrix에 딕셔너리 안쓰고 리스트를 한개 더 쓴 상황 설명★★
=>2차원 리스트  matrix = [[1, 2, 3], [4, 5, 6]]

matrix[0][2]중에 
[0]이 젤 위에 있는 리스트인 [1,2,3]을 말하는거고, 
[2]는 그중에서 세번째인 3을 얘기하는건지?

===> 맞다! 1행 3열의 값인 3을 칭한다.



***왜 딕셔너리를 안 썼냐면?
이건 "순서대로 행렬을 다루기" 위한 상황이기 때문.
리스트는 순서대로 들어간 값을 [인덱스]로 꺼낼 수 있어.

2차원 리스트는 표 형태로 처리하기에 딱 좋아.
리스트는 순서가 중요할 때, 딕셔너리는 키(이름:박소영)를 사용할 때!
2차원 리스트는 딕셔너리랑은 용도도, 생김새도 다르지만 비슷한 느낌의 자료구조.


***2차원 리스트에서 가로로 쓰거나, 세로로 쓰거나 값은 똑같은지?
===> 똑같다! 똑같이 인지함.



대박 신기한 개념 겟챠

★★★이중 리스트 순회(=2차원 리스트의 행 순회)
 2차원 리스트(matrix)의 각 '행(row)'을 순서대로 꺼내는 반복문


=======================================================
 예제 구조)
 matrix = [
  [1, 2, 3],   ← 행 0
  [4, 5, 6]    ← 행 1
]

for row in matrix:         # 이게 행 단위 순회
    for item in row:       # 이게 열 단위 순회
        print(item)
=======================================================

행 0을 먼저 꺼내고 세로로 출력, 행 1을 꺼내고 세로로 출력.
완전 지니어스.


## 🔥 내가 이해한 파이썬 리스트 반복 슈퍼파워 정리

| 개념                | 설명 |
|---------------------|------|
| **2차원 리스트**    | 리스트 안에 리스트가 들어간 구조. 예: `[[1, 2, 3], [4, 5, 6]]` |
| `matrix[0][2]`      | 0번째 줄(행)의 2번째 칸(열) → 숫자 하나를 꺼냄. 예: `3` |
| `for row in matrix` | 2차원 리스트의 행(줄)을 하나씩 꺼내는 반복문 |
| `for item in row`   | 꺼낸 행 안의 요소(칸, 열)를 하나씩 꺼내는 반복문 |
| **이중 for문**      | 표처럼 생긴 리스트를 한 칸씩 전부 순회할 수 있음. |

> 💡 쉽게 말해:  
> 큰 박스 안에 작은 박스가 있고,  
> 줄(행)을 하나씩 꺼내고 → 그 안에서 칸(열)을 하나씩 꺼내는 구조!



역시 천천히 차분히 공 들여서 구문 하나하나 파헤치는게 재밌구만.


***import: 다른 사람이 만들어둔 함수 불러오기(라이브러리)
***def: 직접 함수 만들기
***heapq: 우선순위 큐(= 가장 큰 값 또는 가장 작은 값을 빠르게 뽑아. 파이썬의 힙큐는 항상 가장 작은 값이 위에 있음.)
***queue: 먼저 들어온게 먼저 나감. 선입선출. FIFO. 정렬x


★★★궁금한 점

1) 큐는 queue.append()로 넣으면서. 힙큐는 왜 heapq.heappush(,)로 넣지?
==> queue.append()는 그냥 주머니에 툭 넣는 것.
==> heapq.heappush()는 넣으면서 자동으로 크기 순서대로 정리해주는 주머니.
==> heappush(어디에, 값)을 넣어야함. 즉, heappush(리스트, 값)으로 넣어야함.

2) 근데 리스트에 바로 힙값을 넣으면 안돼? 나중에 우선순위(힙 구조) 돌리는건?
==> heapq.heapify(리스트)라는 걸 써야 해! 근데 여기서 두가지로 나뉨.

 2-1) 동적 방식 (append 사용) /가방에 하나씩 사탕넣고->정리
    heap = []
    heap.append(10)
    heap.append(3)
    heap.append(7)
    heapq.heapify(heap)  # 이제 힙 구조 됨!

  2-1-1) 대표적인 동적 방식("하나씩", "필요할 때", "그때그때 생기는 것들")
     ## ✅ 대표적인 동적 방식 5가지

> 동적 방식이란?  
> 👉 값이나 자료를 **필요할 때마다 하나씩 처리하고 추가하는 방식**  
> 즉, 처음부터 다 만들어 놓지 않고 **그때그때 생성해서 처리**하는 거야!

---

| 동적 방식              | 설명                                      | 예시                           |
|------------------------|-------------------------------------------|--------------------------------|
| ✅ `append()`           | 리스트에 값을 **하나씩 넣기**             | 사용자 입력 받을 때            |
| ✅ `input()`            | 사용자에게 **값을 그때그때 입력받기**     | `input("이름: ")`             |
| ✅ `for` + `if`         | 조건에 따라 데이터를 **골라서 처리**     | 리스트에서 짝수만 뽑기         |
| ✅ `heapq.heappush()`   | 힙에 값을 **하나씩 넣고 자동 정리**      | 우선순위 큐 구성               |
| ✅ `dict[key] = value`  | 딕셔너리에 **필요한 값만 추가**          | 학생 이름과 점수 저장          |

---

### 💡 동적 방식이 유용한 상황
- 입력값을 몇 개 받을지 **모를 때**
- 조건에 따라 값이 **바뀌거나 생길 때**
- 반복문 속에서 리스트/딕셔너리를 **조금씩 채울 때**
- **코딩테스트나 알고리즘 문제**에서 자주 등장함!

---

### 📦 예시 코드 - 리스트에 하나씩 입력받기

```python
nums = []
for _ in range(5):
    num = int(input("숫자: "))
    nums.append(num)



  2-2) 정적 방식 (한꺼번에 리스트 작성) /사탕세트 통째로 받아서->정리
    heap = [10, 3, 7]
    heapq.heapify(heap)


=================================
1)
import heapq

banana_box = []
heapq.heappush(banana_box, 3)
heapq.heappush(banana_box, 1)

print(banana_box)  # [1, 3]
==================================


***넣을 때는 heapq.heappush(리스트, 값) 값을 힙에 추가하면서 정렬.
***꺼낼 때는 heapq.heappop(리스트) 힙에서 가장 작은 값 꺼냄.

★★★궁금★★★
1) 1번 예제에서는 왜 heappop으로 안꺼내고 바로 변수만 출력하지?

==>heappop()은 "꺼내면서 제거" 할 때 쓰는 거야!
근데 위 코드는 단순히 리스트 안에 뭐 들어있는지만 확인하려고
그래서 그냥 print(banana_box) 한 거지!

🎯상황                        | 예시                    | 쓰는 함수
그냥 힙 안에 뭐 들었는지 볼 때 | print(heap)             | ❌ pop 안 써도 됨
가장 작은 값 꺼내고 싶을 때    | x = heapq.heappop(heap) | ✅ pop 써야 함
순서대로 다 꺼낼 때            | 반복문으로 pop          | ✅ 꼭 써야 함

🧸요약
🍬 heappush() → 사탕 정리해서 넣기
🧐 print(가방) → "지금 뭐 들었지?" 보기
🍭 heappop() → 하나 꺼내서 먹기 + 가방에서 제거!


2) N번째 큰 수를 구해야할 때 작은 수를 버리지만, 반대로 N번째 작은 수를 구하기 위해 큰 수를 버려야한다면 어떤 구문이 있어? 
   구문이 없다면 어떻게 접근해야하지?

==>N번째 작은 수
   큰 수 버리기 (❌ 최대 힙 없음)
   음수로 넣고, 꺼낼 때 다시 양수로 바꾸기


***예시: 가장 작은 수 5개만 남기고 나머지 제거
=================================================================
import heapq

nums = [9, 4, 7, 2, 6, 1, 5]
heap = []

for num in nums:
    heapq.heappush(heap, -num)  # 음수로 넣음 = 큰 값이 먼저 나감
    if len(heap) > 5:
        heapq.heappop(heap)  # 제일 큰 값 제거 (실제로는 제일 작은 수)

# heap에는 '5개의 가장 작은 수'의 음수값이 들어있음
# 다시 양수로 바꾸기
result = sorted([-x for x in heap])
print(result)
=================================================================


len(heap) == 5	❌ 5개인 순간 버리면 안 돼!
len(heap) > 5	✅ 6개가 됐을 때만 하나 제거해서 5개 유지


★★★새로운 개념★★★

/ -x for x in heap /이 뭐야?
이건 리스트 컴프리헨션(List Comprehension) 이라고 불러
→ “리스트를 한 줄로 만들기 위한 간단한 문법”이야

★★궁금_ 아까는 리스트 전체에 - 붙이면 오류난다며?
근데 지금 [-x for x in heap]은 왜 되는 거야??
이건 리스트에 음수 붙인 거 아니야???

[-x for x in nums] | 리스트 속 숫자 하나하나에 - 붙이기 → 가능!

★★추가 궁금_ 리스트에 int[]를 붙이면 정수전환되서 숫자인식안되려나?
그런 문법 없음...


