## 문제 분석

N * N 의 표에 $N^2$ 의 수가 채워져 있음.       
모든 수는 자신의 한 칸 위에 있는 수보다 큼.      
*단 표 안의 모든 수는 서로 다름.*

**전체에서 N번째 큰 수를 찾는 프로그램.**

### 입력 값

**첫 번째 입력** : N ($1 \leq N \leq 1500$)      
**다음 입력** : N*N 표

### 출력 값

N번째 큰 수 출력

## 브레인스토밍

맨 밑의 값이 가장 큰 수들의 집합일 가능성이 높음.       
다만, 그 값이 작으면 더 큰 수의 위에 숫자가 보다 큰 수일 수 있음.        

그러면, 가장 큰 수를 기준으로 N + a 탐색하면 됨.         
힙을 사용하면 $\log N$ 삽입 가장 큰 수 기준으로 그 다음수를 찾는건 시간 복잡도가 커짐.      
N 번째로 큰 수를 어떻게 알아내지...          

그냥 단순하게 정렬되어 있다는 점을 기준으로 비교하는 방법이 나을 것 같음.          

근데 잘못된 생각인 것 같음.        
그럴거면 그냥 싹 다 heap에 넣고 찾기.                
그것도 불가함. $N^2$ 만큼 넣어야 해서

일단 그냥 해봤음. 그런데 됨.       
입력값이 1500 정도 수준이기에, 사실상 1500*1500 정도 

N이 충분히 크지 않아서 통과가 가능했음.

### 더 나은 방법에 대한 브레인스토밍

가장 아래쪽부터 위로 올라가는 방식으로 처리할 수는 없나?

저장할 때, index를 함께 붙여서 조회할 수는 없을까?

정렬되어 있다 + 최대 힙을 사용한다면?      
그러면 맨 밑의 N개의 수를 넣고, 가장 최댓값에 대해 그 위의 수를 다시 heapq에 넣음.              
heapq 최대값에 대해 N번 반복한다면, N번째 큰 값을 찾을 수 있음.        

## 문제 회고

> **해당 문제는 메모리 제한이 있음.**        
> 더 나은 풀이에 대해 고찰해보기보다, 정해진 문제 포맷대로 풀이하는 느낌      
> 현재까지 문제 중 최초로 메모리 제한이 크게 걸려 있는 문제


## Sudo

```python
import heapq

N = int(input())
num_list = []
count = 0 # 삽입 횟수 찾기
for _ in range(N):
    num_list.appned(map(int, input().split))

heapq = [(-num_list[N-1][i], N-1, i) for i in range(N)]
# heapq에 마지막 줄 모든 원소를 삽입 이때 (-value, col, row)로 저장

for _ in range(N):
    value, col, row = heapq.heappop()
    if i > 0:
        heapq.heappush((-num_list[col-1][row], col-1, row))

print(-value)
```
 



