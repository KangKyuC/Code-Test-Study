## A. 객체화가 이득인 경우
- 명확한 도메인 모델이 있을 때      
예) 사용자, 주문, 상품 같은 “실세계 개념”을 코드로 직접 표현해야 할 때

- 관련 데이터와 연산이 강하게 묶여 있을 때         
예: Senior는 (week, day, cost)와 “자신의 day_index 계산”, “can_afford” 로직을 언제나 같이 갖고 다니므로

- 재사용·확장성이 중요할 때

- 같은 데이터 타입에 대해 여러 군데서 쓰거나, 서브클래싱(확장)을 예상할 때

- 상태(데이터)를 캡슐화하고 싶을 때

- 내부 구현(예: 인덱스 계산 방법)을 숨기고 “공개 메서드”만 드러내고 싶을 경우

## B. 객체화가 오히려 방해가 될 때
- 단순 변환·계산 로직만 있을 때         
예: 한두 줄짜리 유틸리티 함수(to_day_index(week, day))

- 한 번만 쓰이고 재사용성이 전혀 없을 때          

- 쓰고 버리는 스크립트 차원의 작은 도구라면, 클래스 설계 비용이 더 크다            

- 순수 데이터 전송 구조체(Data-tuple)일 때            

- 가볍게 namedtuple이나 간단한 (w, d, p) 튜플로 충분하다면, 굳이 풀 클래스 설계는 오버헤드         

## 단일 책임 원칙(SRP) 구체적 설명
> “하나의 클래스(또는 함수)는 단 하나의 ‘책임(Reason to Change)’만 가져야 한다.”

- **책임(Responsibility)** 은 “변경 이유”(Reason to Change) 와 일치합니다.

- 예를 들어, ReportGenerator 클래스가

  1. 데이터 조회(SQL)
  2. 보고서 포맷팅(HTML, PDF)
  3. 파일 저장(디스크 I/O)
  4. 메일 전송(네트워크)
  이렇게 네 가지 일을 동시에 한다면,       
  “SQL 문이 바뀌면”, “메일 SMTP 정보가 바뀌면”, “파일 경로 정책이 바뀌면” 등     
  변경 이유가 너무 많아져서 SRP 위반입니다.          

### SRP를 지키는 방법
1. **책임 분리**

   - 데이터 접근 → DataAccess

   - 보고서 생성 → ReportFormatter

   - 저장 → ReportStorage

   - 전송 → MailSender

2. **인터페이스 중심 설계**

- 각 역할을 인터페이스(또는 추상 클래스)로 정의하고,
구체 구현체(예: PdfFormatter, HtmlFormatter)를 DI(의존성 주입)

3. **테스트 용이성↑**
- 각 클래스는 하나의 책임만 테스트하면 되고,       
 목(Mock)객체로 나머지 기능을 대체해 고립된 단위 테스트 가능