### 문제 해석
- 트럭 안에서 추월은 불가함.
- 그러나, 추월하는 인원을 찾기 위한 문제

#### 문제 Input
- 2N+1 개의 입력
  - 첫 번째 줄: 차량의 대수 (N)
  - 그 이후 N개의 줄: 차가 터널에 들어가는 순서
  - 그 이후 N개의 줄: 차가 터널에서 나오는 순서
  - **같은 차량 번호가 두 번 이상 주어지는 경우 없음.**

#### 문제 Output
- **추월한 차량의 대수 (int)**

### 주요 알고리즘

**문제의 핵심**
> 같은 값이 2번 이상 주어지는 경우가 없다.    
> index를 포함한 딕셔너리를 통한 해싱도 가능할 것으로 보임.

조금 더 쉽게 풀 수 있는 방법은 없을까?     
딕셔너리 방식은 직관적이지만, 메모리 할당이 아쉬움.       
index 기반 탐색 방식은 나머지 순서에 대한 보장이 되지 않음.

이론 상 쭉 찾다가, 순서가 바뀐 친구가 나오면 나머지 순서는 1칸씩 밀림.      
- 큐를 이용하면 쉽게 처리 가능하지만, N * N 방식임.

문제의 Hint엔 해시를 사용한 집합과 맵으로 되어 있음.    

아하! 이미 나온 값인지 아닌지만 확인하면 됨.      
나온 차 값은 집합으로 -> 검색에 O(1)
들어간 차 값은 큐로 -> 순서 유지 pop..etc O(1)      

### 수도 코드
```
N 값 저장    
N 번 큐에 저장     
그 다음 N 번 각각 비교연산 수행       
if queue.front == N:
    if queue.front() in 이미 빠져나온 차량:
        이미 나온 차 중에 제거 안된건지 확인
        이미 나온차면 그냥 제거하면 됨. -> 상대적 순서가 그대로임.      
        queue.pop()
    else:
        이미 나온 차 중에 없는데, 값이 같음.
        순서가 유지되어 있는 상태라는 것임.
        queue.pop() 
else:
    값이 다르다 -> 순서가 바뀐 것임
    count ++

return count
     
```
